"""Discussion phase node.

Implements the mandatory discussion phase before planning that:
- Asks clarifying questions about implementation preferences
- Captures developer choices in a CONTEXT.md file
- Prevents incorrect assumptions during implementation

Based on GSD (Get Shit Done) pattern for developer preference capture.
"""

import json
import logging
from datetime import datetime
from pathlib import Path
from typing import Any

from ..state import WorkflowState

logger = logging.getLogger(__name__)

# Discussion question categories with examples
DISCUSSION_QUESTIONS = [
    {
        "category": "libraries",
        "question": "Are there any specific libraries you want to use or avoid?",
        "examples": [
            "Use date-fns NOT moment.js",
            "Prefer axios over fetch",
            "Use zod for validation",
        ],
        "prompt_hint": "List specific library preferences (e.g., 'use X instead of Y')",
    },
    {
        "category": "architecture",
        "question": "What architectural patterns should be followed?",
        "examples": [
            "Repository pattern for data access",
            "Clean architecture",
            "Feature-based folder structure",
        ],
        "prompt_hint": "Describe preferred architectural patterns",
    },
    {
        "category": "testing",
        "question": "What's your testing philosophy?",
        "examples": [
            "Integration tests over unit tests with mocks",
            "E2E tests for critical user flows",
            "100% coverage for business logic",
        ],
        "prompt_hint": "Describe testing preferences and requirements",
    },
    {
        "category": "code_style",
        "question": "Any code style preferences beyond linting rules?",
        "examples": [
            "Early returns preferred",
            "Named exports over default",
            "No classes, use functions",
        ],
        "prompt_hint": "List coding style preferences",
    },
    {
        "category": "error_handling",
        "question": "How should errors be handled?",
        "examples": ["Use Result types", "Central error boundary", "Detailed logging with context"],
        "prompt_hint": "Describe error handling approach",
    },
]

# Template for CONTEXT.md
CONTEXT_MD_TEMPLATE = """# Project Context

Generated by discussion phase on {timestamp}

## Library Preferences
{library_preferences}

## Architectural Decisions
{architecture_decisions}

## Testing Philosophy
{testing_philosophy}

## Code Style
{code_style}

## Error Handling
{error_handling}

## Additional Notes
{additional_notes}

---
*This file captures developer preferences discovered during the discussion phase.*
*Workers should reference this file when making implementation decisions.*
"""


async def discuss_phase_node(state: WorkflowState) -> dict[str, Any]:
    """Mandatory discussion phase before planning.

    Captures developer preferences into CONTEXT.md to ensure
    implementation aligns with project standards.

    This phase:
    1. Checks if CONTEXT.md already exists and is complete
    2. If not, spawns a Claude agent to gather preferences
    3. Generates CONTEXT.md with captured preferences

    Args:
        state: Current workflow state

    Returns:
        State updates with discussion completion status
    """
    project_dir = Path(state["project_dir"])
    context_file = project_dir / "CONTEXT.md"

    logger.info("Starting discussion phase")

    # Check if CONTEXT.md exists and is complete
    if context_file.exists():
        if _is_context_complete(context_file):
            logger.info("CONTEXT.md exists and is complete - skipping discussion")
            preferences = _parse_existing_context(context_file)
            return {
                "discussion_complete": True,
                "context_file": str(context_file),
                "developer_preferences": preferences,
                "updated_at": datetime.now().isoformat(),
            }
        else:
            logger.info("CONTEXT.md exists but incomplete - will enhance")

    # Gather preferences either from existing partial context or interactively
    try:
        preferences = await _gather_preferences(project_dir, state)

        # Save discussion results to database
        _write_context_md(context_file, preferences, state["project_name"])

        logger.info("Discussion phase complete - preferences saved to database")

        return {
            "discussion_complete": True,
            "context_file": str(context_file),
            "developer_preferences": preferences,
            "updated_at": datetime.now().isoformat(),
        }

    except Exception as e:
        logger.error(f"Discussion phase failed: {e}")
        return {
            "discussion_complete": False,
            "errors": [
                {
                    "type": "discussion_phase_error",
                    "message": str(e),
                    "timestamp": datetime.now().isoformat(),
                }
            ],
            "next_decision": "escalate",
            "updated_at": datetime.now().isoformat(),
        }


def _is_context_complete(context_file: Path) -> bool:
    """Check if CONTEXT.md has all required sections populated.

    Args:
        context_file: Path to CONTEXT.md

    Returns:
        True if all sections have content
    """
    try:
        content = context_file.read_text()

        # Required sections that must have content
        required_sections = [
            "## Library Preferences",
            "## Architectural Decisions",
            "## Testing Philosophy",
            "## Code Style",
        ]

        for section in required_sections:
            if section not in content:
                return False

            # Check if section has content (not just placeholder)
            section_start = content.find(section)
            next_section = content.find("##", section_start + len(section))
            if next_section == -1:
                section_content = content[section_start + len(section) :]
            else:
                section_content = content[section_start + len(section) : next_section]

            # Check for placeholder markers
            section_content = section_content.strip()
            if not section_content or "[TBD]" in section_content or "[TODO]" in section_content:
                return False

        return True

    except Exception:
        return False


def _parse_existing_context(context_file: Path) -> dict:
    """Parse existing CONTEXT.md into preferences dict.

    Args:
        context_file: Path to CONTEXT.md

    Returns:
        Dict of preferences by category
    """
    try:
        content = context_file.read_text()
        preferences = {}

        section_mapping = {
            "## Library Preferences": "libraries",
            "## Architectural Decisions": "architecture",
            "## Testing Philosophy": "testing",
            "## Code Style": "code_style",
            "## Error Handling": "error_handling",
            "## Additional Notes": "additional_notes",
        }

        for section_header, key in section_mapping.items():
            if section_header in content:
                section_start = content.find(section_header) + len(section_header)
                next_section = content.find("##", section_start)
                if next_section == -1:
                    section_content = content[section_start:]
                else:
                    section_content = content[section_start:next_section]

                # Parse bullet points
                lines = [
                    line.strip().lstrip("-").strip()
                    for line in section_content.strip().split("\n")
                    if line.strip() and line.strip().startswith("-")
                ]
                preferences[key] = lines if lines else [section_content.strip()]

        return preferences

    except Exception as e:
        logger.warning(f"Failed to parse existing CONTEXT.md: {e}")
        return {}


async def _gather_preferences(
    project_dir: Path,
    state: WorkflowState,
) -> dict[str, list[str]]:
    """Gather developer preferences through analysis and inference.

    This method:
    1. Analyzes existing code patterns in the project
    2. Reads any existing documentation
    3. Infers preferences from existing choices
    4. Falls back to defaults if needed

    Args:
        project_dir: Project directory
        state: Workflow state

    Returns:
        Dict of preferences by category
    """
    preferences: dict[str, list[str]] = {
        "libraries": [],
        "architecture": [],
        "testing": [],
        "code_style": [],
        "error_handling": [],
        "additional_notes": [],
    }

    # Try to infer preferences from existing project files
    inferred = await _infer_preferences_from_project(project_dir)
    for key, values in inferred.items():
        preferences[key].extend(values)

    # Read from PRODUCT.md if it has technical constraints
    product_preferences = _extract_product_preferences(project_dir)
    for key, values in product_preferences.items():
        preferences[key].extend(values)

    # Read from existing CLAUDE.md (worker context) if available
    claude_preferences = _extract_claude_md_preferences(project_dir)
    for key, values in claude_preferences.items():
        preferences[key].extend(values)

    # Deduplicate
    for key in preferences:
        preferences[key] = list(dict.fromkeys(preferences[key]))

    # Add defaults for empty categories
    defaults = {
        "libraries": ["Follow existing project dependencies", "Prefer well-maintained libraries"],
        "architecture": ["Follow existing patterns in the codebase"],
        "testing": ["Write tests for new functionality", "Maintain existing test patterns"],
        "code_style": ["Follow existing code style", "Match surrounding code conventions"],
        "error_handling": ["Log errors with context", "Provide meaningful error messages"],
        "additional_notes": ["No additional notes captured"],
    }

    for key, default_values in defaults.items():
        if not preferences[key]:
            preferences[key] = default_values

    return preferences


async def _infer_preferences_from_project(project_dir: Path) -> dict[str, list[str]]:
    """Infer preferences by analyzing existing project files.

    Args:
        project_dir: Project directory

    Returns:
        Inferred preferences
    """
    preferences: dict[str, list[str]] = {
        "libraries": [],
        "architecture": [],
        "testing": [],
        "code_style": [],
        "error_handling": [],
    }

    # Check package.json for JS/TS projects
    package_json = project_dir / "package.json"
    if package_json.exists():
        try:
            pkg = json.loads(package_json.read_text())
            deps = {**pkg.get("dependencies", {}), **pkg.get("devDependencies", {})}

            # Infer library preferences
            if "date-fns" in deps:
                preferences["libraries"].append("Use date-fns for date manipulation")
            if "moment" in deps:
                preferences["libraries"].append("Project uses moment.js for dates")
            if "axios" in deps:
                preferences["libraries"].append("Use axios for HTTP requests")
            if "zod" in deps:
                preferences["libraries"].append("Use zod for schema validation")
            if "yup" in deps:
                preferences["libraries"].append("Use yup for validation")

            # Infer testing preferences
            if "jest" in deps:
                preferences["testing"].append("Use Jest for testing")
            if "vitest" in deps:
                preferences["testing"].append("Use Vitest for testing")
            if "@testing-library/react" in deps:
                preferences["testing"].append("Use React Testing Library for component tests")
            if "cypress" in deps:
                preferences["testing"].append("Use Cypress for E2E tests")
            if "playwright" in deps:
                preferences["testing"].append("Use Playwright for E2E tests")

            # Infer code style
            if "eslint" in deps:
                preferences["code_style"].append("ESLint enforced")
            if "prettier" in deps:
                preferences["code_style"].append("Prettier for formatting")
            if "typescript" in deps:
                preferences["code_style"].append("TypeScript required")

        except json.JSONDecodeError:
            pass

    # Check pyproject.toml for Python projects
    pyproject = project_dir / "pyproject.toml"
    if pyproject.exists():
        try:
            content = pyproject.read_text()

            # Infer testing
            if "pytest" in content:
                preferences["testing"].append("Use pytest for testing")
            if "coverage" in content:
                preferences["testing"].append("Coverage reporting enabled")

            # Infer code style
            if "ruff" in content:
                preferences["code_style"].append("Ruff for linting and formatting")
            if "black" in content:
                preferences["code_style"].append("Black for formatting")
            if "mypy" in content:
                preferences["code_style"].append("Mypy for type checking")

            # Infer architecture
            if "pydantic" in content:
                preferences["architecture"].append("Use Pydantic for data validation")
            if "sqlalchemy" in content:
                preferences["architecture"].append("SQLAlchemy for database ORM")
            if "fastapi" in content:
                preferences["architecture"].append("FastAPI for API endpoints")

        except Exception:
            pass

    # Check for existing patterns in src directory
    src_dir = project_dir / "src"
    if src_dir.exists():
        # Check for common architecture patterns
        if (src_dir / "repositories").exists() or (src_dir / "repository").exists():
            preferences["architecture"].append("Repository pattern for data access")
        if (src_dir / "services").exists() or (src_dir / "service").exists():
            preferences["architecture"].append("Service layer for business logic")
        if (src_dir / "controllers").exists() or (src_dir / "api").exists():
            preferences["architecture"].append("Controller/API layer for HTTP handling")
        if (src_dir / "domain").exists() or (src_dir / "entities").exists():
            preferences["architecture"].append("Domain-driven design patterns")

    return preferences


def _extract_product_preferences(project_dir: Path) -> dict[str, list[str]]:
    """Extract technical constraints from PRODUCT.md.

    Args:
        project_dir: Project directory

    Returns:
        Preferences from PRODUCT.md
    """
    preferences: dict[str, list[str]] = {
        "libraries": [],
        "architecture": [],
        "testing": [],
        "code_style": [],
        "error_handling": [],
    }

    product_md = project_dir / "PRODUCT.md"
    if not product_md.exists():
        return preferences

    try:
        content = product_md.read_text()

        # Look for Technical Constraints section
        if "## Technical Constraints" in content:
            section_start = content.find("## Technical Constraints")
            next_section = content.find("##", section_start + 20)
            if next_section == -1:
                section_content = content[section_start:]
            else:
                section_content = content[section_start:next_section]

            # Parse constraints into appropriate categories
            lines = [
                line.strip().lstrip("-").strip()
                for line in section_content.split("\n")
                if line.strip().startswith("-")
            ]

            for line in lines:
                line_lower = line.lower()
                if any(kw in line_lower for kw in ["library", "package", "dependency", "use "]):
                    preferences["libraries"].append(line)
                elif any(kw in line_lower for kw in ["pattern", "architecture", "structure"]):
                    preferences["architecture"].append(line)
                elif any(kw in line_lower for kw in ["test", "coverage"]):
                    preferences["testing"].append(line)
                elif any(kw in line_lower for kw in ["performance", "security", "error"]):
                    preferences["error_handling"].append(line)

    except Exception as e:
        logger.warning(f"Failed to extract preferences from PRODUCT.md: {e}")

    return preferences


def _extract_claude_md_preferences(project_dir: Path) -> dict[str, list[str]]:
    """Extract preferences from worker CLAUDE.md if it exists.

    Args:
        project_dir: Project directory

    Returns:
        Preferences from CLAUDE.md
    """
    preferences: dict[str, list[str]] = {
        "libraries": [],
        "architecture": [],
        "testing": [],
        "code_style": [],
        "error_handling": [],
    }

    claude_md = project_dir / "CLAUDE.md"
    if not claude_md.exists():
        return preferences

    try:
        content = claude_md.read_text()

        # Look for coding rules or preferences sections
        sections_to_check = [
            "## Coding Standards",
            "## Code Style",
            "## Preferences",
            "## Rules",
        ]

        for section_header in sections_to_check:
            if section_header in content:
                section_start = content.find(section_header) + len(section_header)
                next_section = content.find("##", section_start)
                if next_section == -1:
                    section_content = content[section_start:]
                else:
                    section_content = content[section_start:next_section]

                lines = [
                    line.strip().lstrip("-").strip()
                    for line in section_content.split("\n")
                    if line.strip().startswith("-")
                ]

                # Categorize based on content
                for line in lines:
                    line_lower = line.lower()
                    if any(kw in line_lower for kw in ["import", "library", "package"]):
                        preferences["libraries"].append(line)
                    elif any(kw in line_lower for kw in ["test", "coverage", "spec"]):
                        preferences["testing"].append(line)
                    elif any(kw in line_lower for kw in ["error", "exception", "log"]):
                        preferences["error_handling"].append(line)
                    else:
                        preferences["code_style"].append(line)

    except Exception as e:
        logger.warning(f"Failed to extract preferences from CLAUDE.md: {e}")

    return preferences


def _write_context_md(
    context_file: Path, preferences: dict[str, list[str]], project_name: str
) -> None:
    """Write CONTEXT.md preferences to database.

    Args:
        context_file: Path (unused - DB storage)
        preferences: Preferences by category
        project_name: Project name for DB storage
    """

    def format_list(items: list[str]) -> str:
        if not items:
            return "- No specific preferences captured"
        return "\n".join(f"- {item}" for item in items)

    content = CONTEXT_MD_TEMPLATE.format(
        timestamp=datetime.now().isoformat(),
        library_preferences=format_list(preferences.get("libraries", [])),
        architecture_decisions=format_list(preferences.get("architecture", [])),
        testing_philosophy=format_list(preferences.get("testing", [])),
        code_style=format_list(preferences.get("code_style", [])),
        error_handling=format_list(preferences.get("error_handling", [])),
        additional_notes=format_list(preferences.get("additional_notes", [])),
    )

    # Save to database
    from ...db.repositories.logs import get_logs_repository
    from ...storage.async_utils import run_async

    repo = get_logs_repository(project_name)
    run_async(
        repo.create_log(
            log_type="discussion", content={"preferences": preferences, "formatted": content}
        )
    )
    logger.info("Discussion preferences saved to database")
